if(商品追加のボタンが押されたら){
  INSERTの処理(トランザクション)
}else if(在庫数変更のボタンが押されたら){
  UPDATE処理(在庫数)
}

・商品追加のボタンを押した→商品追加のコードが実行
・在庫数変更のボタンを押した→在庫数変更のコードが実行
・ステータス変更のボタンを押した→ステータス変更のコードが実行


各変数の初期化処理
<POSTされた場合>
  a. 商品追加のボタンが押されたら
　  商品追加のフォームから値の受け取り
      画像のアップロード
  b. 在庫数変更のボタンが押されたら
      在庫数変更のフォームから値の受け取り
  c. ステータス変更のボタンが押されたら
      ステータス変更のボタンから値の受け取り

  「DBに接続(PDOオブジェクトの生成)」
  a. 商品追加のボタンが押されたら
     トランザクション開始
        商品のテーブルにINSERT
        在庫のテーブルにINSERT
     コミットor ロールバック
  b. 在庫数変更のボタンが押されたら
       在庫のテーブルにUPDATE
  c. ステータス変更のボタンが押されたら
       商品のテーブルにUPDATE

(POSTされていてもいなくても)
SELECT文で商品一覧を取得

<以下はHTML>

//ここの$dsn, $username, $passwordがそれぞれ定数DSN, DB_USER, DB_PASSWDで置き換えられる
1. 初期化
2. issetでのチェック
3. POSTの受け取り（代入）
4. エラーチェック（空文字、正規表現チェックなど）
という順番に行なっていくと、シンプルにかけるのでおすすめです＾＾

ありがとうございます。重複ユーザーのエラーチェックも正規表現チェックの後におこなう形でよろしいですか？
重複ユーザーは、DBのテーブルに登録されているかどうかをチェックすることになるので、
DBの接続後になりますね！DBに接続したらまずは同じ名前のユーザーがいないかどうかチェックして、
その後重複していたらエラーメッセージを出しその後の処理を行わないことになります。
現在はエラーメッセージがあってもなくてもDB接続を実行していらっしゃる状態なので、

1. エラーメッセージは直接プリントするのではなく、$err_msgの配列に代入
2. DB接続前にcount($err_msg)をチェック
3. select文で重複ユーザーをチェック
4. 重複ユーザーがいれば$err_msgの配列にエラーメッセージ
5. count($err_msg)をチェック
6. エラーがなければユーザーをinsert
という大きな流れになります。

1. WHERE user_name = $user_name(入力されたユーザー名)を条件にselect文を実行
2. select文の実行結果が１行以上あればエラーメッセージを表示

2017/7/10
preg_matchはエラーチェックに使うものです。文字列の置換に使うpreg_replaceと
使い方が大きく違うので気をつけましょう。

このような流れになります。
1. 初期化、2. issetで存在チェック 3. 受け取り 4. エラーチェックの流れになっているのがわかりますか？
はい確認させていただきました。preg_matchとpreg_replaceの使い方が混ざってしまっていました。
そうですね！もし、全角と半角の空白を取り除くのであれば、
このように、受け取りの際に取り除いていただくことになります。
もし混乱しそうならば、今回はこの処理を省いていただいてもオッケーです。
承知しました。今一度使い方を確認しておきます。トリムとは違うものなのでしょうか？
通常のtrim関数が「半角スペース」を取り除くのに対して、こちらの処理は「全角・半角両方のスペース」を
取り除くことができますね！
ですので、trimのみ、あるいはスペース削除なしでも、今回はオッケーです！
利便性を上げるための処理ですので、なくてもとりあえずは大丈夫です。S
まずはメイン処理の一連の流れを完成させるのを最優先で進めていきましょう！
商品が購入できるようになってから、エラーチェックや細かい完成度を上げていく作業に入りましょう！